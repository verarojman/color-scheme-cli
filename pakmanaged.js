var global = Function("return this;")();
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

  var oldRequire = require
    , modules = {}
    ;

  function newRequire(modulename) {
    var err
      , mod
      , metamod
      ;

    try {
      mod = oldRequire(modulename);
    } catch(e) {
      err = e;
    }

    if (mod) {
      return mod;
    }

    metamod = modules[modulename];
    
    if (metamod) {
      mod = metamod();
      return mod;
    }

    // make it possible to require 'process', etc
    mod = global[modulename];

    if (mod) {
      return mod;
    }

    console.error(modulename);
    throw err;
  }

  function provide(modulename, factory) {
    var modReal
      ;

    function metamod() {
      if (modReal) {
        return modReal;
      }

      if (!factory.__pakmanager_factory__) {
        modReal = factory;
        return factory;
      }

      if (factory.__factoryIsResolving) {
        console.error('Your circular dependencies are too powerful!');
        return factory.__moduleExports;
      }

      factory.__factoryIsResolving = true;
      factory.__moduleExports = {};
      modReal = factory(factory.__moduleExports);
      factory.__factoryIsResolving = false;

      return modReal;
    }

    modules[modulename] = metamod;
    // somewhat of a dirty hack since I don't have a plug for loading the "main" module otherwise
    modules['pakmanager.main'] = metamod;
  }

  require = newRequire;
  global.require = newRequire;
  global.provide = provide;
}());

// pakmanager:color-scheme
(function (context) {
  function factory(exports) {
  
  var module = { exports: exports }
    ;
  
  // Generated by CoffeeScript 1.12.6
    (function() {
      var ColorScheme,
        slice = [].slice;
    
      ColorScheme = (function() {
        var clone, l, len, ref, typeIsArray, word;
    
        typeIsArray = Array.isArray || function(value) {
          return {}.toString.call(value) === '[object Array]';
        };
    
        ColorScheme.SCHEMES = {};
    
        ref = "mono monochromatic contrast triade tetrade analogic".split(/\s+/);
        for (l = 0, len = ref.length; l < len; l++) {
          word = ref[l];
          ColorScheme.SCHEMES[word] = true;
        }
    
        ColorScheme.PRESETS = {
          "default": [-1, -1, 1, -0.7, 0.25, 1, 0.5, 1],
          pastel: [0.5, -0.9, 0.5, 0.5, 0.1, 0.9, 0.75, 0.75],
          soft: [0.3, -0.8, 0.3, 0.5, 0.1, 0.9, 0.5, 0.75],
          light: [0.25, 1, 0.5, 0.75, 0.1, 1, 0.5, 1],
          hard: [1, -1, 1, -0.6, 0.1, 1, 0.6, 1],
          pale: [0.1, -0.85, 0.1, 0.5, 0.1, 1, 0.1, 0.75]
        };
    
        ColorScheme.COLOR_WHEEL = {
          0: [255, 0, 0, 100],
          15: [255, 51, 0, 100],
          30: [255, 102, 0, 100],
          45: [255, 128, 0, 100],
          60: [255, 153, 0, 100],
          75: [255, 178, 0, 100],
          90: [255, 204, 0, 100],
          105: [255, 229, 0, 100],
          120: [255, 255, 0, 100],
          135: [204, 255, 0, 100],
          150: [153, 255, 0, 100],
          165: [51, 255, 0, 100],
          180: [0, 204, 0, 80],
          195: [0, 178, 102, 70],
          210: [0, 153, 153, 60],
          225: [0, 102, 178, 70],
          240: [0, 51, 204, 80],
          255: [25, 25, 178, 70],
          270: [51, 0, 153, 60],
          285: [64, 0, 153, 60],
          300: [102, 0, 153, 60],
          315: [153, 0, 153, 60],
          330: [204, 0, 153, 80],
          345: [229, 0, 102, 90]
        };
    
        function ColorScheme() {
          var colors, m;
          colors = [];
          for (m = 1; m <= 4; m++) {
            colors.push(new ColorScheme.mutablecolor(60));
          }
          this.col = colors;
          this._scheme = 'mono';
          this._distance = 0.5;
          this._web_safe = false;
          this._add_complement = false;
        }
    
    
        /*
        
        colors()
        
        Returns an array of 4, 8, 12 or 16 colors in RRGGBB hexidecimal notation
        (without a leading "#") depending on the color scheme and addComplement
        parameter. For each set of four, the first is usually the most saturated color,
        the second a darkened version, the third a pale version and fourth
        a less-pale version.
        
        For example: With a contrast scheme, "colors()" would return eight colors.
        Indexes 1 and 5 could be background colors, 2 and 6 could be foreground colors.
        
        Trust me, it's much better if you check out the Color Scheme web site, whose
        URL is listed in "Description"
         */
    
        ColorScheme.prototype.colors = function() {
          var dispatch, h, i, j, m, n, output, ref1, used_colors;
          used_colors = 1;
          h = this.col[0].get_hue();
          dispatch = {
            mono: (function(_this) {
              return function() {};
            })(this),
            contrast: (function(_this) {
              return function() {
                used_colors = 2;
                _this.col[1].set_hue(h);
                return _this.col[1].rotate(180);
              };
            })(this),
            triade: (function(_this) {
              return function() {
                var dif;
                used_colors = 3;
                dif = 60 * _this._distance;
                _this.col[1].set_hue(h);
                _this.col[1].rotate(180 - dif);
                _this.col[2].set_hue(h);
                return _this.col[2].rotate(180 + dif);
              };
            })(this),
            tetrade: (function(_this) {
              return function() {
                var dif;
                used_colors = 4;
                dif = 90 * _this._distance;
                _this.col[1].set_hue(h);
                _this.col[1].rotate(180);
                _this.col[2].set_hue(h);
                _this.col[2].rotate(180 + dif);
                _this.col[3].set_hue(h);
                return _this.col[3].rotate(dif);
              };
            })(this),
            analogic: (function(_this) {
              return function() {
                var dif;
                used_colors = _this._add_complement ? 4 : 3;
                dif = 60 * _this._distance;
                _this.col[1].set_hue(h);
                _this.col[1].rotate(dif);
                _this.col[2].set_hue(h);
                _this.col[2].rotate(360 - dif);
                _this.col[3].set_hue(h);
                return _this.col[3].rotate(180);
              };
            })(this)
          };
          dispatch['monochromatic'] = dispatch['mono'];
          if (dispatch[this._scheme] != null) {
            dispatch[this._scheme]();
          } else {
            throw "Unknown color scheme name: " + this._scheme;
          }
          output = [];
          for (i = m = 0, ref1 = used_colors - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
            for (j = n = 0; n <= 3; j = ++n) {
              output[i * 4 + j] = this.col[i].get_hex(this._web_safe, j);
            }
          }
          return output;
        };
    
    
        /*
        
        colorset()
        
        Returns a list of lists of the colors in groups of four. This method simply
        allows you to reference a color in the scheme by its group isntead of its
        absolute index in the list of colors.  I am assuming that "colorset()"
        will make it easier to use this module with the templating systems that are
        out there.
        
        For example, if you were to follow the synopsis, say you wanted to retrieve
        the two darkest colors from the first two groups of the scheme, which is
        typically the second color in the group. You could retrieve them with
        "colors()"
        
            first_background  = (scheme.colors())[1];
            second_background = (scheme.colors())[5];
        
        Or, with this method,
        
            first_background  = (scheme.colorset())[0][1]
            second_background = (scheme.colorset())[1][1]
         */
    
        ColorScheme.prototype.colorset = function() {
          var flat_colors, grouped_colors;
          flat_colors = clone(this.colors());
          grouped_colors = [];
          while (flat_colors.length > 0) {
            grouped_colors.push(flat_colors.splice(0, 4));
          }
          return grouped_colors;
        };
    
    
        /*
        
        from_hue( degrees )
        
        Sets the base color hue, where 'degrees' is an integer. (Values greater than
        359 and less than 0 wrap back around the wheel.)
        
        The default base hue is 0, or bright red.
         */
    
        ColorScheme.prototype.from_hue = function(h) {
          if (h == null) {
            throw "from_hue needs an argument";
          }
          this.col[0].set_hue(h);
          return this;
        };
    
        ColorScheme.prototype.rgb2ryb = function() {
          var blue, green, iN, maxgreen, maxyellow, red, rgb, white, yellow;
          rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if ((rgb[0] != null) && typeIsArray(rgb[0])) {
            rgb = rgb[0];
          }
          red = rgb[0], green = rgb[1], blue = rgb[2];
          white = Math.min(red, green, blue);
          red -= white;
          green -= white;
          blue -= white;
          maxgreen = Math.max(red, green, blue);
          yellow = Math.min(red, green);
          red -= yellow;
          green -= yellow;
          if (blue > 0 && green > 0) {
            blue /= 2;
            green /= 2;
          }
          yellow += green;
          blue += green;
          maxyellow = Math.max(red, yellow, blue);
          if (maxyellow > 0) {
            iN = maxgreen / maxyellow;
            red *= iN;
            yellow *= iN;
            blue *= iN;
          }
          red += white;
          yellow += white;
          blue += white;
          return [Math.floor(red), Math.floor(yellow), Math.floor(blue)];
        };
    
        ColorScheme.prototype.rgb2hsv = function() {
          var b, d, g, h, max, min, r, rgb, s, v;
          rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if ((rgb[0] != null) && typeIsArray(rgb[0])) {
            rgb = rgb[0];
          }
          r = rgb[0], g = rgb[1], b = rgb[2];
          r /= 255;
          g /= 255;
          b /= 255;
          min = Math.min.apply(Math, [r, g, b]);
          max = Math.max.apply(Math, [r, g, b]);
          d = max - min;
          v = max;
          s;
          if (d > 0) {
            s = d / max;
          } else {
            return [0, 0, v];
          }
          h = (r === max ? (g - b) / d : (g === max ? 2 + (b - r) / d : 4 + (r - g) / d));
          h *= 60;
          h %= 360;
          return [h, s, v];
        };
    
        ColorScheme.prototype.rgbToHsv = function() {
          var b, d, g, h, max, min, r, rgb, s, v;
          rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if ((rgb[0] != null) && typeIsArray(rgb[0])) {
            rgb = rgb[0];
          }
          r = rgb[0], g = rgb[1], b = rgb[2];
          r /= 255;
          g /= 255;
          b /= 255;
          max = Math.max(r, g, b);
          min = Math.min(r, g, b);
          h = void 0;
          s = void 0;
          v = max;
          d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max === min) {
            h = 0;
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
            }
            h /= 6;
          }
          return [h, s, v];
        };
    
    
        /*
        
        from_hex( color )
        
        Sets the base color to the given color, where 'color' is in the hexidecimal
        form RRGGBB. 'color' should not be preceded with a hash (#).
        
        The default base color is the equivalent of #ff0000, or bright red.
         */
    
        ColorScheme.prototype.from_hex = function(hex) {
          var b, g, h, h0, h1, h2, hsv, i1, i2, num, r, ref1, ref2, rgbcap, s, v;
          if (hex == null) {
            throw "from_hex needs an argument";
          }
          if (!/^([0-9A-F]{2}){3}$/im.test(hex)) {
            throw "from_hex(" + hex + ") - argument must be in the form of RRGGBB";
          }
          rgbcap = /(..)(..)(..)/.exec(hex).slice(1, 4);
          ref1 = (function() {
            var len1, m, results;
            results = [];
            for (m = 0, len1 = rgbcap.length; m < len1; m++) {
              num = rgbcap[m];
              results.push(parseInt(num, 16));
            }
            return results;
          })(), r = ref1[0], g = ref1[1], b = ref1[2];
          ref2 = this.rgb2ryb([r, g, b]), r = ref2[0], g = ref2[1], b = ref2[2];
          hsv = this.rgbToHsv(r, g, b);
          h0 = hsv[0];
          h1 = 0;
          h2 = 1000;
          i1 = null;
          i2 = null;
          h = null;
          s = null;
          v = null;
          h = hsv[0];
          s = hsv[1];
          v = hsv[2];
          this.from_hue(h * 360);
          this._set_variant_preset([s, v, s, v * 0.7, s * 0.25, 1, s * 0.5, 1]);
          return this;
        };
    
    
        /*
        
        add_complement( BOOLEAN )
        
        If BOOLEAN is true, an extra set of colors will be produced using the
        complement of the selected color.
        
        This only works with the analogic color scheme. The default is false.
         */
    
        ColorScheme.prototype.add_complement = function(b) {
          if (b == null) {
            throw "add_complement needs an argument";
          }
          this._add_complement = b;
          return this;
        };
    
    
        /*
        
        web_safe( BOOL )
        
        Sets whether the colors returned by L<"colors()"> or L<"colorset()"> will be
        web-safe.
        
        The default is false.
         */
    
        ColorScheme.prototype.web_safe = function(b) {
          if (b == null) {
            throw "web_safe needs an argument";
          }
          this._web_safe = b;
          return this;
        };
    
    
        /*
        
        distance( FLOAT )
        
        'FLOAT'> must be a value from 0 to 1. You might use this with the "triade"
        "tetrade" or "analogic" color schemes.
        
        The default is 0.5.
         */
    
        ColorScheme.prototype.distance = function(d) {
          if (d == null) {
            throw "distance needs an argument";
          }
          if (d < 0) {
            throw "distance(" + d + ") - argument must be >= 0";
          }
          if (d > 1) {
            throw "distance(" + d + ") - argument must be <= 1";
          }
          this._distance = d;
          return this;
        };
    
    
        /*
        
        scheme( name )
        
        'name' must be a valid color scheme name. See "Color Schemes". The default
        is "mono"
         */
    
        ColorScheme.prototype.scheme = function(name) {
          if (name == null) {
            return this._scheme;
          } else {
            if (ColorScheme.SCHEMES[name] == null) {
              throw "'" + name + "' isn't a valid scheme name";
            }
            this._scheme = name;
            return this;
          }
        };
    
    
        /*
        
        variation( name )
        
        'name' must be a valid color variation name. See "Color Variations"
         */
    
        ColorScheme.prototype.variation = function(v) {
          if (v == null) {
            throw "variation needs an argument";
          }
          if (ColorScheme.PRESETS[v] == null) {
            throw "'$v' isn't a valid variation name";
          }
          this._set_variant_preset(ColorScheme.PRESETS[v]);
          return this;
        };
    
        ColorScheme.prototype._set_variant_preset = function(p) {
          var i, m, results;
          results = [];
          for (i = m = 0; m <= 3; i = ++m) {
            results.push(this.col[i].set_variant_preset(p));
          }
          return results;
        };
    
        clone = function(obj) {
          var flags, key, newInstance;
          if ((obj == null) || typeof obj !== 'object') {
            return obj;
          }
          if (obj instanceof Date) {
            return new Date(obj.getTime());
          }
          if (obj instanceof RegExp) {
            flags = '';
            if (obj.global != null) {
              flags += 'g';
            }
            if (obj.ignoreCase != null) {
              flags += 'i';
            }
            if (obj.multiline != null) {
              flags += 'm';
            }
            if (obj.sticky != null) {
              flags += 'y';
            }
            return new RegExp(obj.source, flags);
          }
          newInstance = new obj.constructor();
          for (key in obj) {
            newInstance[key] = clone(obj[key]);
          }
          return newInstance;
        };
    
        ColorScheme.mutablecolor = (function() {
          mutablecolor.prototype.hue = 0;
    
          mutablecolor.prototype.saturation = [];
    
          mutablecolor.prototype.value = [];
    
          mutablecolor.prototype.base_red = 0;
    
          mutablecolor.prototype.base_green = 0;
    
          mutablecolor.prototype.base_saturation = 0;
    
          mutablecolor.prototype.base_value = 0;
    
          function mutablecolor(hue) {
            if (hue == null) {
              throw "No hue specified";
            }
            this.saturation = [];
            this.value = [];
            this.base_red = 0;
            this.base_green = 0;
            this.base_blue = 0;
            this.base_saturation = 0;
            this.base_value = 0;
            this.set_hue(hue);
            this.set_variant_preset(ColorScheme.PRESETS['default']);
          }
    
          mutablecolor.prototype.get_hue = function() {
            return this.hue;
          };
    
          mutablecolor.prototype.set_hue = function(h) {
            var avrg, color, colorset1, colorset2, d, derivative1, derivative2, en, i, k;
            avrg = function(a, b, k) {
              return a + Math.round((b - a) * k);
            };
            this.hue = Math.round(h % 360);
            d = this.hue % 15 + (this.hue - Math.floor(this.hue));
            k = d / 15;
            derivative1 = this.hue - Math.floor(d);
            derivative2 = (derivative1 + 15) % 360;
            colorset1 = ColorScheme.COLOR_WHEEL[derivative1];
            colorset2 = ColorScheme.COLOR_WHEEL[derivative2];
            en = {
              red: 0,
              green: 1,
              blue: 2,
              value: 3
            };
            for (color in en) {
              i = en[color];
              this["base_" + color] = avrg(colorset1[i], colorset2[i], k);
            }
            this.base_saturation = avrg(100, 100, k) / 100;
            return this.base_value /= 100;
          };
    
          mutablecolor.prototype.rotate = function(angle) {
            var newhue;
            newhue = (this.hue + angle) % 360;
            return this.set_hue(newhue);
          };
    
          mutablecolor.prototype.get_saturation = function(variation) {
            var s, x;
            x = this.saturation[variation];
            s = x < 0 ? -x * this.base_saturation : x;
            if (s > 1) {
              s = 1;
            }
            if (s < 0) {
              s = 0;
            }
            return s;
          };
    
          mutablecolor.prototype.get_value = function(variation) {
            var v, x;
            x = this.value[variation];
            v = x < 0 ? -x * this.base_value : x;
            if (v > 1) {
              v = 1;
            }
            if (v < 0) {
              v = 0;
            }
            return v;
          };
    
          mutablecolor.prototype.set_variant = function(variation, s, v) {
            this.saturation[variation] = s;
            return this.value[variation] = v;
          };
    
          mutablecolor.prototype.set_variant_preset = function(p) {
            var i, m, results;
            results = [];
            for (i = m = 0; m <= 3; i = ++m) {
              results.push(this.set_variant(i, p[2 * i], p[2 * i + 1]));
            }
            return results;
          };
    
          mutablecolor.prototype.get_hex = function(web_safe, variation) {
            var c, color, formatted, i, k, len1, len2, m, max, min, n, ref1, rgb, rgbVal, s, str, v;
            max = Math.max.apply(Math, (function() {
              var len1, m, ref1, results;
              ref1 = ['red', 'green', 'blue'];
              results = [];
              for (m = 0, len1 = ref1.length; m < len1; m++) {
                color = ref1[m];
                results.push(this["base_" + color]);
              }
              return results;
            }).call(this));
            min = Math.min.apply(Math, (function() {
              var len1, m, ref1, results;
              ref1 = ['red', 'green', 'blue'];
              results = [];
              for (m = 0, len1 = ref1.length; m < len1; m++) {
                color = ref1[m];
                results.push(this["base_" + color]);
              }
              return results;
            }).call(this));
            v = (variation < 0 ? this.base_value : this.get_value(variation)) * 255;
            s = variation < 0 ? this.base_saturation : this.get_saturation(variation);
            k = max > 0 ? v / max : 0;
            rgb = [];
            ref1 = ['red', 'green', 'blue'];
            for (m = 0, len1 = ref1.length; m < len1; m++) {
              color = ref1[m];
              rgbVal = Math.min.apply(Math, [255, Math.round(v - (v - this["base_" + color] * k) * s)]);
              rgb.push(rgbVal);
            }
            if (web_safe) {
              rgb = (function() {
                var len2, n, results;
                results = [];
                for (n = 0, len2 = rgb.length; n < len2; n++) {
                  c = rgb[n];
                  results.push(Math.round(c / 51) * 51);
                }
                return results;
              })();
            }
            formatted = "";
            for (n = 0, len2 = rgb.length; n < len2; n++) {
              i = rgb[n];
              str = i.toString(16);
              if (str.length < 2) {
                str = "0" + str;
              }
              formatted += str;
            }
            return formatted;
          };
    
          return mutablecolor;
    
        })();
    
        return ColorScheme;
    
      })();
    
      if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
        module.exports = ColorScheme;
      } else {
        if (typeof define === 'function' && define.amd) {
          define([], function() {
            return ColorScheme;
          });
        } else {
          window.ColorScheme = ColorScheme;
        }
      }
    
    }).call(this);
    
    //# sourceMappingURL=color-scheme.js.map
    
    return module.exports;
  }
  factory.__pakmanager_factory__ = true;
  provide("color-scheme", factory);
}(global));

// pakmanager:commander
(function (context) {
  function factory(exports) {
  
  var module = { exports: exports }
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = {};
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name || '';
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
        if (opts.isDefault) this.defaultExecutable = cmd._name;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    };
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on('command:' + name, listener);
      if (this._alias) parent.on('command:' + this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|*} [fn] or default
     * @param {*} [defaultValue]
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on('option:' + oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3 && !this.defaultExecutable) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
    
      var aliasCommand = null;
      // check alias of sub commands
      if (name) {
        aliasCommand = this.commands.filter(function(command) {
          return command.alias() === name;
        })[0];
      }
    
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      } else if (aliasCommand) {
        // is alias of a subCommand
        args[0] = aliasCommand._name;
        return this.executeSubCommand(argv, args, parsed.unknown);
      } else if (this.defaultExecutable) {
        // use the default subcommand
        args.unshift(this.defaultExecutable);
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = fs.lstatSync(f).isSymbolicLink() ? fs.readlinkSync(f) : f;
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(bin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(bin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach(function(signal) {
        process.on(signal, function(){
          if ((proc.killed === false) && (proc.exitCode === null)){
            proc.kill(signal);
          }
        });
      });
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      // Store the reference to the child process
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners('command:' + name).length) {
          this.emit('command:' + args.shift(), args, unknown);
        } else {
          this.emit('command:*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if (literal) {
          args.push(arg);
          continue;
        }
    
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit('option:' + option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit('option:' + option.name(), arg);
          // bool
          } else {
            this.emit('option:' + option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} [flags]
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('option:version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 === arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      var command = this;
      if(this.commands.length !== 0) {
        command = this.commands[this.commands.length - 1]
      }
    
      if (arguments.length === 0) return command._alias;
    
      command._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get or set the name of the command
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function(str) {
      if (0 === arguments.length) return this._name;
      this._name = str;
      return this;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Append the help information
      return this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
        }).concat([pad('-h, --help', width) + '  ' + 'output usage information'])
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias ? '|' + cmd._alias : '')
            + (cmd.options.length ? ' [options]' : '')
            + ' ' + args
          , cmd._description
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
        ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          var desc = cmd[1] ? '  ' + cmd[1] : '';
          return pad(cmd[0], width) + desc;
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        ''
        , '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
      ];
    
      return usage
        .concat(desc)
        .concat(options)
        .concat(cmds)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function(cb) {
      if (!cb) {
        cb = function(passthru) {
          return passthru;
        }
      }
      process.stdout.write(cb(this.helpInformation()));
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function(cb) {
      this.outputHelp(cb);
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
    return module.exports;
  }
  factory.__pakmanager_factory__ = true;
  provide("commander", factory);
}(global));

// pakmanager:color-scheme-cli
(function (context) {
  function factory(exports) {
  
  var module = { exports: exports }
    ;
  
  var ColorScheme = require('color-scheme');
    var program = require('commander');
     
    program
      .version('0.1.0')
      .option('-s, --scheme <scheme>', 'Scheme type (mono, contrast, triade, tetrade, analogic)')
      .option('-v, --variation <variation>', 'Variation (default, pastel, soft, light, hard, pale)')
      .option('-d, --distance <i>', 'Distance')
      .option('-h, --from-hue <i>', 'From hue <hue>', parseInt)
      .option('-H, --from-hex [value]', 'From hex [value]')
      .parse(process.argv);
     
    
    console.log("")
    
    if (program.scheme)
    	console.log("	Scheme:		%s", program.scheme)
    if (program.variation)
    	console.log("	Variation:	%s", program.variation)
    if (program.distance)
    	console.log("	Distance:	%s", program.distance)
    if (program.fromHue)
    	console.log("	Hue:		%s", program.fromHue)
    if (program.fromHex)
    	console.log("	Hex:		%s", program.fromHex)
    
    console.log("")
    console.log("	-----------------------")
    console.log("")
    
    var s = new ColorScheme;
    
    	s.from_hue(program.fromHue || 0);
    
    	if (program.fromHex) {
    		if (program.fromHex.toString().length) {
    			s.from_hex(program.fromHex);
    		}
    	}
    
    	s.scheme(program.scheme || 'mono').variation(program.variation || 'default');
    
    	if (program.distance && program.scheme) {
    		if ("triade tetrade analogic".indexOf(program.scheme) >= 0) {
    			s.distance(program.distance);
    		}
    	}
    
    	var i = 0;
    	s.colors().forEach(function(color) {
    		console.log("	Color %j: 	#%s", ++i, color);
    	});
    
    
    console.log("")
    return module.exports;
  }
  factory.__pakmanager_factory__ = true;
  provide("color-scheme-cli", factory);
}(global));
require("pakmanager.main");